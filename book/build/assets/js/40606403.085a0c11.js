"use strict";(globalThis.webpackChunkmy_book_site=globalThis.webpackChunkmy_book_site||[]).push([[428],{2721:(o,n,t)=>{t.r(n),t.d(n,{assets:()=>l,contentTitle:()=>r,default:()=>m,frontMatter:()=>a,metadata:()=>e,toc:()=>d});const e=JSON.parse('{"id":"chapter8-multirobot","title":"Chapter 8: Multi-Robot Coordination for Humanoid Systems","description":"Introduction to Multi-Robot Systems","source":"@site/docs/chapter8-multirobot.md","sourceDirName":".","slug":"/chapter8-multirobot","permalink":"/my_book/docs/chapter8-multirobot","draft":false,"unlisted":false,"editUrl":"https://github.com/Ayesha788/my_book/tree/main/docs/chapter8-multirobot.md","tags":[],"version":"current","frontMatter":{},"sidebar":"tutorialSidebar","previous":{"title":"Chapter 7: Manipulation and Grasping for Humanoid Robots","permalink":"/my_book/docs/chapter7-manipulation"},"next":{"title":"Chapter 9: Learning and Adaptation for Humanoid Robots","permalink":"/my_book/docs/chapter9-learning"}}');var s=t(4848),i=t(8453);const a={},r="Chapter 8: Multi-Robot Coordination for Humanoid Systems",l={},d=[{value:"Introduction to Multi-Robot Systems",id:"introduction-to-multi-robot-systems",level:2},{value:"Coordination Architectures",id:"coordination-architectures",level:2},{value:"Centralized vs. Decentralized Coordination",id:"centralized-vs-decentralized-coordination",level:3},{value:"Communication Protocols for Humanoid Robots",id:"communication-protocols-for-humanoid-robots",level:2},{value:"ROS 2 Multi-Robot Communication",id:"ros-2-multi-robot-communication",level:3},{value:"Task Allocation Algorithms",id:"task-allocation-algorithms",level:2},{value:"Market-Based Task Allocation",id:"market-based-task-allocation",level:3},{value:"Formation Control for Humanoid Robots",id:"formation-control-for-humanoid-robots",level:2},{value:"Virtual Structure Formation",id:"virtual-structure-formation",level:3},{value:"Human-Robot Team Coordination",id:"human-robot-team-coordination",level:2},{value:"Socially-Aware Coordination",id:"socially-aware-coordination",level:3},{value:"Coordination Algorithms Implementation",id:"coordination-algorithms-implementation",level:2},{value:"ROS 2 Coordination Node",id:"ros-2-coordination-node",level:3},{value:"Challenges in Multi-Robot Coordination",id:"challenges-in-multi-robot-coordination",level:2},{value:"Communication Constraints",id:"communication-constraints",level:3},{value:"Heterogeneous Teams",id:"heterogeneous-teams",level:3},{value:"Dynamic Environments",id:"dynamic-environments",level:3},{value:"Practice Tasks",id:"practice-tasks",level:2},{value:"Summary",id:"summary",level:2}];function c(o){const n={code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,i.R)(),...o.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.header,{children:(0,s.jsx)(n.h1,{id:"chapter-8-multi-robot-coordination-for-humanoid-systems",children:"Chapter 8: Multi-Robot Coordination for Humanoid Systems"})}),"\n",(0,s.jsx)(n.h2,{id:"introduction-to-multi-robot-systems",children:"Introduction to Multi-Robot Systems"}),"\n",(0,s.jsx)(n.p,{children:"Multi-robot coordination involves multiple autonomous robots working together to achieve common goals. In the context of humanoid robotics, this presents unique challenges due to the complexity of individual robots and their anthropomorphic nature, which makes them suitable for human-centered environments."}),"\n",(0,s.jsx)(n.h2,{id:"coordination-architectures",children:"Coordination Architectures"}),"\n",(0,s.jsx)(n.h3,{id:"centralized-vs-decentralized-coordination",children:"Centralized vs. Decentralized Coordination"}),"\n",(0,s.jsx)(n.p,{children:"Multi-robot systems can be organized using different coordination architectures, each with specific advantages for humanoid robot teams:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-python",children:'import numpy as np\nfrom enum import Enum\nfrom dataclasses import dataclass\nfrom typing import List, Dict, Optional\n\nclass CoordinationType(Enum):\n    CENTRALIZED = "centralized"\n    DECENTRALIZED = "decentralized"\n    HYBRID = "hybrid"\n\n@dataclass\nclass RobotState:\n    robot_id: str\n    position: np.ndarray  # [x, y, z]\n    orientation: np.ndarray  # [roll, pitch, yaw]\n    status: str  # idle, moving, working, etc.\n    battery_level: float\n    task_queue: List[str]\n\nclass CentralizedCoordinator:\n    def __init__(self):\n        self.robots: Dict[str, RobotState] = {}\n        self.tasks = []\n        self.communication_range = 10.0  # meters\n\n    def register_robot(self, robot_state: RobotState):\n        """Register a robot with the central coordinator"""\n        self.robots[robot_state.robot_id] = robot_state\n\n    def assign_task(self, robot_id: str, task: str):\n        """Assign a task to a specific robot"""\n        if robot_id in self.robots:\n            self.robots[robot_id].task_queue.append(task)\n            return True\n        return False\n\n    def coordinate_movement(self):\n        """Coordinate movement to avoid collisions"""\n        robot_positions = [(id, state.position) for id, state in self.robots.items()]\n\n        for i, (id1, pos1) in enumerate(robot_positions):\n            for id2, pos2 in robot_positions[i+1:]:\n                distance = np.linalg.norm(pos1 - pos2)\n                if distance < 1.0:  # Collision threshold\n                    # Implement collision avoidance\n                    self.resolve_collision(id1, id2, pos1, pos2)\n\n    def resolve_collision(self, id1: str, id2: str, pos1: np.ndarray, pos2: np.ndarray):\n        """Resolve collision between two robots"""\n        # Simple strategy: move one robot aside\n        direction = pos2 - pos1\n        direction = direction / np.linalg.norm(direction)\n\n        # Move robot2 to the side\n        self.robots[id2].position += direction * 0.5\n\nclass DecentralizedCoordinator:\n    def __init__(self, robot_id: str):\n        self.robot_id = robot_id\n        self.neighbors: Dict[str, RobotState] = {}\n        self.local_tasks = []\n        self.communication_range = 10.0\n\n    def broadcast_state(self, state: RobotState):\n        """Broadcast current state to neighbors"""\n        # In a real system, this would send messages over network\n        pass\n\n    def receive_neighbor_state(self, neighbor_state: RobotState):\n        """Receive state from a neighboring robot"""\n        self.neighbors[neighbor_state.robot_id] = neighbor_state\n\n    def make_local_decision(self, global_tasks: List[str]):\n        """Make coordination decisions based on local information"""\n        # Check for potential conflicts with neighbors\n        for neighbor_id, neighbor_state in self.neighbors.items():\n            if self.would_conflict(neighbor_state):\n                # Adjust behavior to avoid conflict\n                self.adjust_behavior(neighbor_state)\n\n    def would_conflict(self, neighbor_state: RobotState) -> bool:\n        """Check if current plan would conflict with neighbor"""\n        # Check if paths intersect or if both heading to same location\n        distance = np.linalg.norm(self.robots[self.robot_id].position - neighbor_state.position)\n        return distance < 2.0  # Potential conflict threshold\n\n    def adjust_behavior(self, neighbor_state: RobotState):\n        """Adjust behavior to avoid conflict"""\n        # Implement local coordination strategy\n        pass\n'})}),"\n",(0,s.jsx)(n.h2,{id:"communication-protocols-for-humanoid-robots",children:"Communication Protocols for Humanoid Robots"}),"\n",(0,s.jsx)(n.h3,{id:"ros-2-multi-robot-communication",children:"ROS 2 Multi-Robot Communication"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-python",children:'import rclpy\nfrom rclpy.node import Node\nfrom std_msgs.msg import String, Float32MultiArray\nfrom geometry_msgs.msg import PoseStamped\nfrom multirobot_msgs.msg import RobotStatus, TaskAssignment\n\nclass MultiRobotCommunicator(Node):\n    def __init__(self, robot_id: str):\n        super().__init__(f\'multirobot_comm_{robot_id}\')\n        self.robot_id = robot_id\n\n        # Publishers\n        self.status_pub = self.create_publisher(RobotStatus, \'robot_status\', 10)\n        self.task_pub = self.create_publisher(TaskAssignment, \'task_assignments\', 10)\n        self.pose_pub = self.create_publisher(PoseStamped, \'robot_pose\', 10)\n\n        # Subscribers\n        self.status_sub = self.create_subscription(\n            RobotStatus, \'robot_status\', self.status_callback, 10\n        )\n        self.task_sub = self.create_subscription(\n            TaskAssignment, \'task_assignments\', self.task_callback, 10\n        )\n        self.coordination_sub = self.create_subscription(\n            String, \'coordination_channel\', self.coordination_callback, 10\n        )\n\n        # Timer for periodic status updates\n        self.status_timer = self.create_timer(1.0, self.publish_status)\n\n        # Robot state\n        self.current_pose = PoseStamped()\n        self.battery_level = 100.0\n        self.task_queue = []\n\n    def publish_status(self):\n        """Publish current robot status"""\n        status_msg = RobotStatus()\n        status_msg.robot_id = self.robot_id\n        status_msg.pose = self.current_pose.pose\n        status_msg.battery_level = self.battery_level\n        status_msg.status = "active"  # idle, working, charging, etc.\n\n        self.status_pub.publish(status_msg)\n\n    def status_callback(self, msg: RobotStatus):\n        """Handle incoming robot status"""\n        if msg.robot_id != self.robot_id:\n            # Update neighbor information\n            self.update_neighbor_status(msg)\n\n    def task_callback(self, msg: TaskAssignment):\n        """Handle incoming task assignment"""\n        if msg.target_robot == self.robot_id:\n            self.task_queue.append(msg.task)\n            self.execute_task(msg.task)\n\n    def coordination_callback(self, msg: String):\n        """Handle coordination messages"""\n        coordination_data = msg.data.split(\':\')\n        if coordination_data[0] == \'request\':\n            self.handle_coordination_request(coordination_data[1:])\n        elif coordination_data[0] == \'response\':\n            self.handle_coordination_response(coordination_data[1:])\n\n    def update_neighbor_status(self, status: RobotStatus):\n        """Update information about neighboring robots"""\n        # Store in local coordination data structure\n        pass\n\n    def execute_task(self, task: str):\n        """Execute a specific task"""\n        # Implementation depends on task type\n        pass\n\n    def handle_coordination_request(self, request_data):\n        """Handle coordination requests from other robots"""\n        # Process request and send response\n        pass\n\n    def handle_coordination_response(self, response_data):\n        """Handle coordination responses"""\n        # Process response and update plans accordingly\n        pass\n'})}),"\n",(0,s.jsx)(n.h2,{id:"task-allocation-algorithms",children:"Task Allocation Algorithms"}),"\n",(0,s.jsx)(n.h3,{id:"market-based-task-allocation",children:"Market-Based Task Allocation"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-python",children:'class TaskAllocator:\n    def __init__(self, robots: List[str]):\n        self.robots = robots\n        self.tasks = []\n        self.robot_capabilities = {}  # Robot -> capabilities mapping\n        self.task_requirements = {}   # Task -> requirements mapping\n\n    def register_robot_capabilities(self, robot_id: str, capabilities: Dict[str, float]):\n        """Register what capabilities a robot has"""\n        self.robot_capabilities[robot_id] = capabilities\n\n    def register_task(self, task_id: str, requirements: Dict[str, float], value: float = 1.0):\n        """Register a task with its requirements and value"""\n        self.tasks.append({\n            \'id\': task_id,\n            \'requirements\': requirements,\n            \'value\': value,\n            \'assigned_to\': None\n        })\n\n    def auction_tasks(self) -> Dict[str, List[str]]:\n        """Auction tasks to robots using market-based approach"""\n        robot_assignments = {robot: [] for robot in self.robots}\n\n        for task in self.tasks:\n            if task[\'assigned_to\'] is None:\n                # Calculate bids from all robots\n                bids = {}\n                for robot in self.robots:\n                    bid = self.calculate_bid(robot, task)\n                    if bid > 0:  # Only robots that can perform the task\n                        bids[robot] = bid\n\n                if bids:\n                    # Assign to highest bidder\n                    winning_robot = max(bids, key=bids.get)\n                    robot_assignments[winning_robot].append(task[\'id\'])\n                    task[\'assigned_to\'] = winning_robot\n\n        return robot_assignments\n\n    def calculate_bid(self, robot_id: str, task: Dict) -> float:\n        """Calculate how much a robot should bid for a task"""\n        if robot_id not in self.robot_capabilities:\n            return 0\n\n        robot_caps = self.robot_capabilities[robot_id]\n        task_reqs = task[\'requirements\']\n\n        # Calculate capability match score\n        match_score = 1.0\n        for req, req_value in task_reqs.items():\n            if req in robot_caps:\n                # Higher capability means higher bid\n                match_score *= (robot_caps[req] / req_value)\n            else:\n                # Robot doesn\'t have required capability\n                return 0\n\n        # Higher task value increases bid\n        bid = task[\'value\'] * match_score\n\n        # Consider robot\'s current workload\n        current_tasks = len([t for t in self.tasks if t[\'assigned_to\'] == robot_id])\n        workload_factor = max(0.5, 1.0 - current_tasks * 0.1)  # Reduce bid with more tasks\n\n        return bid * workload_factor\n\nclass ConsensusBasedBundleAlgorithm:\n    """Implementation of CBBA (Consensus-Based Bundle Algorithm)"""\n\n    def __init__(self, robots: List[str], tasks: List[Dict]):\n        self.robots = robots\n        self.tasks = tasks\n        self.robot_bundles = {r: [] for r in robots}\n        self.robot_paths = {r: [] for r in robots}\n        self.time_limit = 10.0  # Consensus time limit\n\n    def run_cbba(self) -> Dict[str, List[str]]:\n        """Run the CBBA algorithm to allocate tasks"""\n        # Initialize bundles\n        for robot in self.robots:\n            self.robot_bundles[robot] = []\n            self.robot_paths[robot] = []\n\n        # Iterative consensus process\n        iteration = 0\n        max_iterations = 50\n        converged = False\n\n        while not converged and iteration < max_iterations:\n            old_assignments = {r: self.robot_bundles[r][:] for r in self.robots}\n\n            # Each robot builds its bundle\n            for robot in self.robots:\n                self.update_robot_bundle(robot)\n\n            # Check for convergence\n            converged = all(\n                self.robot_bundles[r] == old_assignments[r] for r in self.robots\n            )\n            iteration += 1\n\n        return self.robot_bundles\n\n    def update_robot_bundle(self, robot_id: str):\n        """Update a robot\'s task bundle"""\n        current_bundle = self.robot_bundles[robot_id]\n        available_tasks = [t for t in self.tasks if t[\'id\'] not in\n                          [item[\'id\'] for bundle_list in self.robot_bundles.values() for item in bundle_list]]\n\n        # Add best tasks to bundle\n        for task in available_tasks:\n            if self.is_task_beneficial(robot_id, task, current_bundle):\n                current_bundle.append(task)\n\n    def is_task_beneficial(self, robot_id: str, task: Dict, current_bundle: List[Dict]) -> bool:\n        """Check if adding a task is beneficial for the robot"""\n        # Calculate utility of adding this task to current bundle\n        # This would involve path planning and cost calculations\n        return True  # Simplified for example\n'})}),"\n",(0,s.jsx)(n.h2,{id:"formation-control-for-humanoid-robots",children:"Formation Control for Humanoid Robots"}),"\n",(0,s.jsx)(n.h3,{id:"virtual-structure-formation",children:"Virtual Structure Formation"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-python",children:'class FormationController:\n    def __init__(self, robot_id: str, formation_shape: str = "line"):\n        self.robot_id = robot_id\n        self.formation_shape = formation_shape\n        self.neighbors = []\n        self.formation_positions = {}\n        self.current_position = np.array([0.0, 0.0, 0.0])\n        self.formation_scale = 1.0\n\n    def setup_formation(self, robot_ids: List[str], leader_id: str = None):\n        """Set up formation positions for all robots"""\n        n_robots = len(robot_ids)\n\n        if self.formation_shape == "line":\n            self.calculate_line_formation(robot_ids)\n        elif self.formation_shape == "circle":\n            self.calculate_circle_formation(robot_ids)\n        elif self.formation_shape == "triangle":\n            self.calculate_triangle_formation(robot_ids)\n\n    def calculate_line_formation(self, robot_ids: List[str]):\n        """Calculate positions for line formation"""\n        leader_idx = robot_ids.index(self.robot_id)\n\n        for i, robot_id in enumerate(robot_ids):\n            offset = (i - leader_idx) * self.formation_scale\n            self.formation_positions[robot_id] = np.array([offset, 0.0, 0.0])\n\n    def calculate_circle_formation(self, robot_ids: List[str]):\n        """Calculate positions for circular formation"""\n        n_robots = len(robot_ids)\n        angle_step = 2 * np.pi / n_robots\n\n        for i, robot_id in enumerate(robot_ids):\n            angle = i * angle_step\n            x = self.formation_scale * np.cos(angle)\n            y = self.formation_scale * np.sin(angle)\n            self.formation_positions[robot_id] = np.array([x, y, 0.0])\n\n    def calculate_triangle_formation(self, robot_ids: List[str]):\n        """Calculate positions for triangular formation"""\n        n_robots = len(robot_ids)\n\n        for i, robot_id in enumerate(robot_ids):\n            if n_robots >= 3:\n                if i == 0:\n                    # Leader at center\n                    self.formation_positions[robot_id] = np.array([0.0, 0.0, 0.0])\n                elif i == 1:\n                    # First follower\n                    self.formation_positions[robot_id] = np.array([self.formation_scale, 0.0, 0.0])\n                elif i == 2:\n                    # Second follower\n                    angle = np.pi / 3  # 60 degrees\n                    x = self.formation_scale * np.cos(angle)\n                    y = self.formation_scale * np.sin(angle)\n                    self.formation_positions[robot_id] = np.array([x, y, 0.0])\n\n    def compute_formation_control(self, leader_position: np.ndarray) -> np.ndarray:\n        """Compute control input to maintain formation"""\n        desired_position = leader_position + self.formation_positions[self.robot_id]\n\n        # Simple proportional controller\n        error = desired_position - self.current_position\n        control_output = 1.0 * error  # Proportional gain = 1.0\n\n        # Add collision avoidance with other robots\n        avoidance_force = self.compute_collision_avoidance()\n\n        return control_output + avoidance_force\n\n    def compute_collision_avoidance(self) -> np.ndarray:\n        """Compute collision avoidance forces"""\n        avoidance_force = np.zeros(3)\n\n        for neighbor_id, neighbor_pos in self.formation_positions.items():\n            if neighbor_id != self.robot_id:\n                distance = np.linalg.norm(self.current_position - neighbor_pos)\n                if distance < 0.5:  # Collision threshold\n                    # Repulsive force\n                    direction = self.current_position - neighbor_pos\n                    direction = direction / np.linalg.norm(direction)\n                    magnitude = max(0, 0.5 - distance) * 10.0\n                    avoidance_force += direction * magnitude\n\n        return avoidance_force\n'})}),"\n",(0,s.jsx)(n.h2,{id:"human-robot-team-coordination",children:"Human-Robot Team Coordination"}),"\n",(0,s.jsx)(n.h3,{id:"socially-aware-coordination",children:"Socially-Aware Coordination"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-python",children:'class SociallyAwareCoordinator:\n    def __init__(self, robot_id: str):\n        self.robot_id = robot_id\n        self.human_positions = {}\n        self.social_zones = {}  # Personal, social, public space distances\n        self.approach_strategies = {}\n\n    def detect_humans(self, human_detections: List[Dict]):\n        """Process human detections and update internal state"""\n        for detection in human_detections:\n            human_id = detection[\'id\']\n            position = detection[\'position\']\n            self.human_positions[human_id] = position\n\n    def plan_socially_compliant_path(self, goal, humans_nearby: List[str]):\n        """Plan a path that respects human social spaces"""\n        # Define social zones\n        personal_space = 0.45  # meters\n        social_space = 1.2    # meters\n        public_space = 3.6    # meters\n\n        # Modify path planning to avoid human personal space\n        modified_goal = self.adjust_goal_for_social_compliance(goal, humans_nearby)\n\n        # Return socially compliant path\n        return self.compute_path_to_goal(modified_goal)\n\n    def adjust_goal_for_social_compliance(self, goal, humans_nearby: List[str]):\n        """Adjust goal to respect human social spaces"""\n        adjusted_goal = goal.copy()\n\n        for human_id in humans_nearby:\n            if human_id in self.human_positions:\n                human_pos = self.human_positions[human_id]\n\n                # Calculate vector from human to goal\n                vec_to_goal = adjusted_goal - human_pos[:3]  # Only x,y,z\n                distance = np.linalg.norm(vec_to_goal)\n\n                if distance < 1.2:  # Within social space\n                    # Adjust goal to maintain minimum distance\n                    direction = vec_to_goal / distance if distance > 0 else np.array([1, 0, 0])\n                    adjusted_goal = human_pos[:3] + direction * 1.2\n\n        return adjusted_goal\n\n    def compute_path_to_goal(self, goal):\n        """Compute path to goal (simplified)"""\n        # In practice, this would use a proper path planning algorithm\n        return [goal]  # Return the goal as the path\n\n    def select_interaction_strategy(self, human_state: Dict):\n        """Select appropriate interaction strategy based on human state"""\n        if human_state[\'is_looking_at_robot\']:\n            return "direct_interaction"\n        elif human_state[\'is_in_conversation\']:\n            return "wait_for_turn"\n        elif human_state[\'appears_hurrying\']:\n            return "minimize_interruption"\n        else:\n            return "normal_interaction"\n'})}),"\n",(0,s.jsx)(n.h2,{id:"coordination-algorithms-implementation",children:"Coordination Algorithms Implementation"}),"\n",(0,s.jsx)(n.h3,{id:"ros-2-coordination-node",children:"ROS 2 Coordination Node"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-python",children:'import rclpy\nfrom rclpy.node import Node\nfrom multirobot_msgs.msg import CoordinationCommand, CoordinationStatus\nfrom geometry_msgs.msg import PoseStamped\nfrom std_msgs.msg import String\n\nclass MultiRobotCoordinator(Node):\n    def __init__(self):\n        super().__init__(\'multirobot_coordinator\')\n\n        # Publishers\n        self.coord_cmd_pub = self.create_publisher(\n            CoordinationCommand, \'coordination_commands\', 10\n        )\n        self.coord_status_pub = self.create_publisher(\n            CoordinationStatus, \'coordination_status\', 10\n        )\n\n        # Subscribers\n        self.pose_sub = self.create_subscription(\n            PoseStamped, \'robot_pose\', self.pose_callback, 10\n        )\n        self.coord_status_sub = self.create_subscription(\n            CoordinationStatus, \'coordination_status\', self.coord_status_callback, 10\n        )\n\n        # Coordination components\n        self.task_allocator = TaskAllocator(robots=[])\n        self.formation_controller = FormationController(\n            robot_id=self.get_namespace(), formation_shape="line"\n        )\n        self.social_coordinator = SociallyAwareCoordinator(\n            robot_id=self.get_namespace()\n        )\n\n        # Timer for coordination updates\n        self.coordination_timer = self.create_timer(0.5, self.coordination_step)\n\n        # Robot states\n        self.robot_states = {}\n        self.human_states = {}\n\n    def pose_callback(self, msg: PoseStamped):\n        """Update robot pose in coordination system"""\n        robot_id = self.get_namespace()  # Simplified\n        self.robot_states[robot_id] = msg.pose\n\n    def coord_status_callback(self, msg: CoordinationStatus):\n        """Process coordination status from other robots"""\n        self.robot_states[msg.robot_id] = msg.pose\n        if msg.robot_id != self.get_namespace():\n            # Update formation controller with neighbor positions\n            self.formation_controller.current_position = np.array([\n                msg.pose.position.x, msg.pose.position.y, msg.pose.position.z\n            ])\n\n    def coordination_step(self):\n        """Main coordination step"""\n        # Update formation\n        if len(self.robot_states) > 1:\n            leader_id = min(self.robot_states.keys())  # Simple leader selection\n            if self.get_namespace() != leader_id:\n                leader_pose = self.robot_states[leader_id]\n                leader_pos = np.array([\n                    leader_pose.position.x,\n                    leader_pose.position.y,\n                    leader_pose.position.z\n                ])\n\n                control_cmd = self.formation_controller.compute_formation_control(leader_pos)\n\n                # Publish coordination command\n                cmd_msg = CoordinationCommand()\n                cmd_msg.robot_id = self.get_namespace()\n                cmd_msg.command = "move_to"\n                cmd_msg.target_position = control_cmd.tolist()\n                self.coord_cmd_pub.publish(cmd_msg)\n\n        # Update coordination status\n        status_msg = CoordinationStatus()\n        status_msg.robot_id = self.get_namespace()\n        if self.get_namespace() in self.robot_states:\n            status_msg.pose = self.robot_states[self.get_namespace()]\n        status_msg.status = "coordinating"\n        self.coord_status_pub.publish(status_msg)\n'})}),"\n",(0,s.jsx)(n.h2,{id:"challenges-in-multi-robot-coordination",children:"Challenges in Multi-Robot Coordination"}),"\n",(0,s.jsx)(n.h3,{id:"communication-constraints",children:"Communication Constraints"}),"\n",(0,s.jsx)(n.p,{children:"Humanoid robots face specific communication challenges:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Bandwidth limitations"}),": Complex humanoid robots generate large amounts of sensor data"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Latency requirements"}),": Real-time coordination needs low-latency communication"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Reliability"}),": Coordination failures can lead to safety issues"]}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"heterogeneous-teams",children:"Heterogeneous Teams"}),"\n",(0,s.jsx)(n.p,{children:"Coordination becomes more complex with different robot types:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Different capabilities and limitations"}),"\n",(0,s.jsx)(n.li,{children:"Varying mobility and manipulation abilities"}),"\n",(0,s.jsx)(n.li,{children:"Different sensing modalities"}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"dynamic-environments",children:"Dynamic Environments"}),"\n",(0,s.jsx)(n.p,{children:"Real-world environments require adaptive coordination:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Moving obstacles"}),"\n",(0,s.jsx)(n.li,{children:"Changing task requirements"}),"\n",(0,s.jsx)(n.li,{children:"Unpredictable human interactions"}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"practice-tasks",children:"Practice Tasks"}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsx)(n.li,{children:"Implement a simple multi-robot communication system using ROS 2"}),"\n",(0,s.jsx)(n.li,{children:"Create a task allocation algorithm for a team of humanoid robots"}),"\n",(0,s.jsx)(n.li,{children:"Develop a formation control system for coordinated movement"}),"\n",(0,s.jsx)(n.li,{children:"Design socially-aware navigation for human-robot teams"}),"\n",(0,s.jsx)(n.li,{children:"Test coordination algorithms in simulation with multiple robots"}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"summary",children:"Summary"}),"\n",(0,s.jsx)(n.p,{children:"Multi-robot coordination for humanoid systems requires sophisticated algorithms that consider the complexity of individual robots, human-aware interactions, and real-time constraints. By implementing proper coordination architectures, communication protocols, and task allocation strategies, teams of humanoid robots can effectively work together to accomplish complex tasks in human-centered environments."})]})}function m(o={}){const{wrapper:n}={...(0,i.R)(),...o.components};return n?(0,s.jsx)(n,{...o,children:(0,s.jsx)(c,{...o})}):c(o)}},8453:(o,n,t)=>{t.d(n,{R:()=>a,x:()=>r});var e=t(6540);const s={},i=e.createContext(s);function a(o){const n=e.useContext(i);return e.useMemo(function(){return"function"==typeof o?o(n):{...n,...o}},[n,o])}function r(o){let n;return n=o.disableParentContext?"function"==typeof o.components?o.components(s):o.components||s:a(o.components),e.createElement(i.Provider,{value:n},o.children)}}}]);