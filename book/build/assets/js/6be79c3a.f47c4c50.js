"use strict";(globalThis.webpackChunkmy_book_site=globalThis.webpackChunkmy_book_site||[]).push([[471],{1275:(n,e,a)=>{a.r(e),a.d(e,{assets:()=>l,contentTitle:()=>s,default:()=>d,frontMatter:()=>r,metadata:()=>t,toc:()=>c});const t=JSON.parse('{"id":"chapter5-path-planning","title":"Chapter 5: Path Planning and Navigation for Humanoid Robots","description":"Introduction to Path Planning","source":"@site/docs/chapter5-path-planning.md","sourceDirName":".","slug":"/chapter5-path-planning","permalink":"/my_book/docs/chapter5-path-planning","draft":false,"unlisted":false,"editUrl":"https://github.com/Ayesha788/my_book/tree/main/docs/chapter5-path-planning.md","tags":[],"version":"current","frontMatter":{},"sidebar":"tutorialSidebar","previous":{"title":"Chapter 4: Vision-Language-Action (VLA) - Converting Voice Commands to Robot Actions","permalink":"/my_book/docs/chapter4-vla"},"next":{"title":"Chapter 6: Computer Vision for Humanoid Robotics","permalink":"/my_book/docs/chapter6-computer-vision"}}');var o=a(4848),i=a(8453);const r={},s="Chapter 5: Path Planning and Navigation for Humanoid Robots",l={},c=[{value:"Introduction to Path Planning",id:"introduction-to-path-planning",level:2},{value:"Types of Path Planning",id:"types-of-path-planning",level:2},{value:"Global Path Planning",id:"global-path-planning",level:3},{value:"Local Path Planning",id:"local-path-planning",level:3},{value:"Footstep Planning Algorithms",id:"footstep-planning-algorithms",level:2},{value:"A* Algorithm for Footstep Planning",id:"a-algorithm-for-footstep-planning",level:3},{value:"Navigation Stack for Humanoid Robots",id:"navigation-stack-for-humanoid-robots",level:2},{value:"Overview",id:"overview",level:3},{value:"Costmap Configuration for Humanoid Robots",id:"costmap-configuration-for-humanoid-robots",level:3},{value:"Dynamic Balance and Walking Patterns",id:"dynamic-balance-and-walking-patterns",level:2},{value:"ZMP (Zero Moment Point) Planning",id:"zmp-zero-moment-point-planning",level:3},{value:"Practical Implementation",id:"practical-implementation",level:2},{value:"Setting up Navigation for a Humanoid Robot",id:"setting-up-navigation-for-a-humanoid-robot",level:3},{value:"Challenges in Humanoid Navigation",id:"challenges-in-humanoid-navigation",level:2},{value:"Balance Maintenance",id:"balance-maintenance",level:3},{value:"Terrain Adaptation",id:"terrain-adaptation",level:3},{value:"Practice Tasks",id:"practice-tasks",level:2},{value:"Summary",id:"summary",level:2}];function p(n){const e={code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,i.R)(),...n.components};return(0,o.jsxs)(o.Fragment,{children:[(0,o.jsx)(e.header,{children:(0,o.jsx)(e.h1,{id:"chapter-5-path-planning-and-navigation-for-humanoid-robots",children:"Chapter 5: Path Planning and Navigation for Humanoid Robots"})}),"\n",(0,o.jsx)(e.h2,{id:"introduction-to-path-planning",children:"Introduction to Path Planning"}),"\n",(0,o.jsx)(e.p,{children:"Path planning is a critical component of humanoid robotics, enabling robots to navigate complex environments while avoiding obstacles and reaching desired goals. Unlike wheeled robots, humanoid robots face unique challenges due to their bipedal locomotion, balance constraints, and complex kinematics."}),"\n",(0,o.jsx)(e.h2,{id:"types-of-path-planning",children:"Types of Path Planning"}),"\n",(0,o.jsx)(e.h3,{id:"global-path-planning",children:"Global Path Planning"}),"\n",(0,o.jsx)(e.p,{children:"Global path planning involves finding an optimal path from a start position to a goal position based on a known map of the environment. For humanoid robots, this must account for:"}),"\n",(0,o.jsxs)(e.ul,{children:["\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.strong,{children:"Footstep planning"}),": Ensuring stable placement of feet along the path"]}),"\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.strong,{children:"Center of Mass (CoM) trajectory"}),": Maintaining balance throughout the path"]}),"\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.strong,{children:"Kinematic constraints"}),": Joint limits and workspace boundaries"]}),"\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.strong,{children:"Stability requirements"}),": Maintaining static or dynamic balance"]}),"\n"]}),"\n",(0,o.jsx)(e.h3,{id:"local-path-planning",children:"Local Path Planning"}),"\n",(0,o.jsx)(e.p,{children:"Local path planning handles real-time obstacle avoidance and path adjustments based on sensor data. For humanoid robots, this includes:"}),"\n",(0,o.jsxs)(e.ul,{children:["\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.strong,{children:"Dynamic obstacle avoidance"}),": Moving objects in the environment"]}),"\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.strong,{children:"Reactive stepping"}),": Adjusting foot placement in real-time"]}),"\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.strong,{children:"Balance recovery"}),": Adjusting posture to maintain stability"]}),"\n"]}),"\n",(0,o.jsx)(e.h2,{id:"footstep-planning-algorithms",children:"Footstep Planning Algorithms"}),"\n",(0,o.jsx)(e.h3,{id:"a-algorithm-for-footstep-planning",children:"A* Algorithm for Footstep Planning"}),"\n",(0,o.jsx)(e.p,{children:"The A* algorithm can be adapted for humanoid footstep planning by considering the robot's bipedal nature:"}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-python",children:'import numpy as np\nfrom heapq import heappop, heappush\n\nclass FootstepPlanner:\n    def __init__(self, map_resolution=0.1):\n        self.resolution = map_resolution\n        # Additional humanoid-specific parameters\n        self.step_length = 0.3  # Maximum step length\n        self.step_width = 0.2   # Lateral step capability\n        self.max_step_height = 0.1  # Maximum step-over height\n\n    def plan_footsteps(self, start_pose, goal_pose, occupancy_grid):\n        """\n        Plan a sequence of footsteps from start to goal\n        """\n        # Convert to grid coordinates\n        start_cell = self.pose_to_grid(start_pose)\n        goal_cell = self.pose_to_grid(goal_pose)\n\n        # Priority queue for A* algorithm\n        open_set = [(0, start_cell, [])]  # (f_score, cell, path)\n        closed_set = set()\n\n        while open_set:\n            current_f, current_cell, current_path = heappop(open_set)\n\n            if current_cell == goal_cell:\n                return current_path + [current_cell]\n\n            if current_cell in closed_set:\n                continue\n\n            closed_set.add(current_cell)\n\n            # Generate possible next footsteps\n            for next_step in self.get_valid_footsteps(current_cell, occupancy_grid):\n                if next_step not in closed_set:\n                    new_path = current_path + [current_cell]\n                    g_score = len(new_path)  # Simple path cost\n                    h_score = self.heuristic(next_step, goal_cell)\n                    f_score = g_score + h_score\n\n                    heappush(open_set, (f_score, next_step, new_path))\n\n        return None  # No path found\n\n    def get_valid_footsteps(self, current_cell, occupancy_grid):\n        """\n        Generate valid next footsteps based on humanoid constraints\n        """\n        footsteps = []\n        # Consider possible step directions and distances\n        for dx in [-1, 0, 1]:\n            for dy in [-1, 0, 1]:\n                if dx == 0 and dy == 0:\n                    continue  # Skip current position\n\n                next_cell = (current_cell[0] + dx, current_cell[1] + dy)\n\n                # Check if the next position is valid\n                if self.is_valid_footstep(next_cell, occupancy_grid):\n                    footsteps.append(next_cell)\n\n        return footsteps\n\n    def is_valid_footstep(self, cell, occupancy_grid):\n        """\n        Check if a footstep is valid (not in collision)\n        """\n        if (cell[0] < 0 or cell[0] >= occupancy_grid.shape[0] or\n            cell[1] < 0 or cell[1] >= occupancy_grid.shape[1]):\n            return False  # Out of bounds\n\n        return occupancy_grid[cell] == 0  # Free space\n'})}),"\n",(0,o.jsx)(e.h2,{id:"navigation-stack-for-humanoid-robots",children:"Navigation Stack for Humanoid Robots"}),"\n",(0,o.jsx)(e.h3,{id:"overview",children:"Overview"}),"\n",(0,o.jsx)(e.p,{children:"The navigation stack for humanoid robots extends the traditional ROS navigation stack with humanoid-specific components:"}),"\n",(0,o.jsxs)(e.ol,{children:["\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.strong,{children:"Costmap Generation"}),": Creating costmaps that account for humanoid-specific constraints"]}),"\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.strong,{children:"Footstep Planner"}),": Planning stable footsteps"]}),"\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.strong,{children:"Trajectory Controller"}),": Generating dynamically stable trajectories"]}),"\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.strong,{children:"Local Planner"}),": Adjusting path based on sensor feedback"]}),"\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.strong,{children:"Recovery Behaviors"}),": Handling navigation failures while maintaining balance"]}),"\n"]}),"\n",(0,o.jsx)(e.h3,{id:"costmap-configuration-for-humanoid-robots",children:"Costmap Configuration for Humanoid Robots"}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-yaml",children:"# costmap_common_params.yaml\nmap_type: costmap\n\n# Robot footprint - considering the humanoid's base\nfootprint: [[-0.3, -0.2], [-0.3, 0.2], [0.3, 0.2], [0.3, -0.2]]\nfootprint_padding: 0.05\n\n# Obstacle range should account for sensor placement on humanoid\nobstacle_range: 3.0\nraytrace_range: 4.0\n\n# Humanoid-specific inflation\ninflation_radius: 0.5\ncost_scaling_factor: 5.0\n\n# Sensors used for costmap\nobservation_sources: laser_scan_sensor point_cloud_sensor\n\nlaser_scan_sensor:\n  sensor_frame: base_scan\n  topic: /scan\n  observation_range: 3.0\n  raytrace_range: 4.0\n  max_obstacle_height: 2.0\n  min_obstacle_height: 0.0\n  obstacle_range: 3.0\n"})}),"\n",(0,o.jsx)(e.h2,{id:"dynamic-balance-and-walking-patterns",children:"Dynamic Balance and Walking Patterns"}),"\n",(0,o.jsx)(e.h3,{id:"zmp-zero-moment-point-planning",children:"ZMP (Zero Moment Point) Planning"}),"\n",(0,o.jsx)(e.p,{children:"For stable bipedal locomotion, humanoid robots must maintain their ZMP within the support polygon defined by their feet:"}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-python",children:'class ZMPController:\n    def __init__(self):\n        self.com_height = 0.8  # Center of mass height\n        self.gravity = 9.81\n        self.omega = np.sqrt(self.gravity / self.com_height)\n\n    def compute_zmp_trajectory(self, footsteps, step_time, double_support_ratio=0.2):\n        """\n        Compute ZMP trajectory based on footsteps\n        """\n        zmp_trajectory = []\n\n        for i, (foot_pos, foot_yaw) in enumerate(footsteps):\n            # Calculate ZMP for single support phase\n            single_support_time = step_time * (1 - double_support_ratio)\n\n            # ZMP moves from previous foot position to current foot position\n            if i > 0:\n                prev_foot_pos = footsteps[i-1][0]\n                for t in np.arange(0, single_support_time, 0.01):\n                    # Interpolate ZMP position\n                    alpha = t / single_support_time\n                    zmp_x = (1 - alpha) * prev_foot_pos[0] + alpha * foot_pos[0]\n                    zmp_y = (1 - alpha) * prev_foot_pos[1] + alpha * foot_pos[1]\n                    zmp_trajectory.append([zmp_x, zmp_y])\n\n        return zmp_trajectory\n'})}),"\n",(0,o.jsx)(e.h2,{id:"practical-implementation",children:"Practical Implementation"}),"\n",(0,o.jsx)(e.h3,{id:"setting-up-navigation-for-a-humanoid-robot",children:"Setting up Navigation for a Humanoid Robot"}),"\n",(0,o.jsxs)(e.ol,{children:["\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.strong,{children:"Create a navigation configuration package"}),":"]}),"\n"]}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-bash",children:"mkdir -p ~/ros2_ws/src/humanoid_navigation/config\nmkdir -p ~/ros2_ws/src/humanoid_navigation/launch\nmkdir -p ~/ros2_ws/src/humanoid_navigation/maps\n"})}),"\n",(0,o.jsxs)(e.ol,{start:"2",children:["\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.strong,{children:"Create a launch file for navigation"}),":"]}),"\n"]}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-python",children:"# launch/navigation.launch.py\nimport os\nfrom launch import LaunchDescription\nfrom launch.actions import DeclareLaunchArgument\nfrom launch.substitutions import LaunchConfiguration\nfrom launch_ros.actions import Node\nfrom ament_index_python.packages import get_package_share_directory\n\ndef generate_launch_description():\n    # Config file paths\n    config_dir = os.path.join(\n        get_package_share_directory('humanoid_navigation'),\n        'config'\n    )\n\n    return LaunchDescription([\n        # AMCL for localization\n        Node(\n            package='nav2_amcl',\n            executable='amcl',\n            name='amcl',\n            parameters=[os.path.join(config_dir, 'amcl.yaml')]\n        ),\n\n        # Map server\n        Node(\n            package='nav2_map_server',\n            executable='map_server',\n            name='map_server',\n            parameters=[os.path.join(config_dir, 'map_server.yaml')]\n        ),\n\n        # Planner server\n        Node(\n            package='nav2_bt_navigator',\n            executable='bt_navigator',\n            name='bt_navigator',\n            parameters=[os.path.join(config_dir, 'bt_navigator.yaml')]\n        ),\n\n        # Controller server\n        Node(\n            package='nav2_controller',\n            executable='controller_server',\n            name='controller_server',\n            parameters=[os.path.join(config_dir, 'controller.yaml')]\n        )\n    ])\n"})}),"\n",(0,o.jsx)(e.h2,{id:"challenges-in-humanoid-navigation",children:"Challenges in Humanoid Navigation"}),"\n",(0,o.jsx)(e.h3,{id:"balance-maintenance",children:"Balance Maintenance"}),"\n",(0,o.jsx)(e.p,{children:"The primary challenge in humanoid navigation is maintaining balance while executing navigation commands. This requires:"}),"\n",(0,o.jsxs)(e.ul,{children:["\n",(0,o.jsx)(e.li,{children:"Real-time balance feedback and adjustment"}),"\n",(0,o.jsx)(e.li,{children:"Coordination between walking pattern generation and navigation planning"}),"\n",(0,o.jsx)(e.li,{children:"Robust recovery behaviors when balance is compromised"}),"\n"]}),"\n",(0,o.jsx)(e.h3,{id:"terrain-adaptation",children:"Terrain Adaptation"}),"\n",(0,o.jsx)(e.p,{children:"Humanoid robots must adapt to various terrains:"}),"\n",(0,o.jsxs)(e.ul,{children:["\n",(0,o.jsx)(e.li,{children:"Stairs and steps"}),"\n",(0,o.jsx)(e.li,{children:"Uneven surfaces"}),"\n",(0,o.jsx)(e.li,{children:"Sloped terrain"}),"\n",(0,o.jsx)(e.li,{children:"Narrow passages"}),"\n"]}),"\n",(0,o.jsx)(e.h2,{id:"practice-tasks",children:"Practice Tasks"}),"\n",(0,o.jsxs)(e.ol,{children:["\n",(0,o.jsx)(e.li,{children:"Implement a simple footstep planner that can navigate around static obstacles"}),"\n",(0,o.jsx)(e.li,{children:"Create a ZMP-based walking pattern generator"}),"\n",(0,o.jsx)(e.li,{children:"Integrate the footstep planner with a basic navigation stack"}),"\n",(0,o.jsx)(e.li,{children:"Test navigation performance on different terrain types in simulation"}),"\n",(0,o.jsx)(e.li,{children:"Implement recovery behaviors for when the robot loses balance during navigation"}),"\n"]}),"\n",(0,o.jsx)(e.h2,{id:"summary",children:"Summary"}),"\n",(0,o.jsx)(e.p,{children:"Path planning and navigation for humanoid robots requires specialized algorithms that account for the robot's bipedal nature and balance constraints. By combining traditional path planning techniques with humanoid-specific considerations, we can enable robots to navigate complex environments safely and efficiently."})]})}function d(n={}){const{wrapper:e}={...(0,i.R)(),...n.components};return e?(0,o.jsx)(e,{...n,children:(0,o.jsx)(p,{...n})}):p(n)}},8453:(n,e,a)=>{a.d(e,{R:()=>r,x:()=>s});var t=a(6540);const o={},i=t.createContext(o);function r(n){const e=t.useContext(i);return t.useMemo(function(){return"function"==typeof n?n(e):{...e,...n}},[e,n])}function s(n){let e;return e=n.disableParentContext?"function"==typeof n.components?n.components(o):n.components||o:r(n.components),t.createElement(i.Provider,{value:e},n.children)}}}]);